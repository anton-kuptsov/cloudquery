package fetch

import (
	"context"
	"fmt"

	"github.com/cloudquery/cloudquery/internal/plugin"
	"github.com/cloudquery/cq-provider-sdk/plugins"
	"github.com/cloudquery/cq-provider-sdk/spec"
	"github.com/spf13/cobra"
	"golang.org/x/sync/errgroup"
)

const (
	fetchShort = "Fetch resources from configured source plugins to destination"
	fetchLong  = `Fetch resources from configured source plugins to destination
	
	This requires a cloudquery.yml file which can be generated by "cloudquery init"
	`
	fetchExample = `  # Fetch configured providers to PostgreSQL as configured in cloudquery.yml
	cloudquery fetch`
)

func NewCmdFetch() *cobra.Command {
	cmd := &cobra.Command{
		Use:     "fetch",
		Short:   fetchShort,
		Long:    fetchLong,
		Example: fetchExample,
		Args:    cobra.RangeArgs(0, 1),
		RunE:    fetch,
	}
	return cmd
}

func fetch(cmd *cobra.Command, args []string) error {
	directory := "."
	if len(args) == 1 {
		directory = args[0]
	}
	fmt.Println("Loading specs from directory: ", directory)
	specReader, err := spec.NewSpecReader(directory)
	if err != nil {
		return fmt.Errorf("failed to load specs from directory %s: %w", directory, err)
	}
	if len(specReader.Connections()) == 0 {
		fmt.Println("No connections specs found in directory: ", directory)
		return nil
	}
	pm := plugin.NewPluginManager()
	defer pm.CloseAll(cmd.Context())
	for _, connSpec := range specReader.Connections() {
		if err := fetchConnection(cmd.Context(), specReader, connSpec, pm); err != nil {
			return fmt.Errorf("failed to fetch connection %s->%s: %w", connSpec.Source, connSpec.Destination, err)
		}
		// destSpec := specs.GetDestinatinoByName(connSpec.Destination)
	}

	return nil
}

func fetchConnection(ctx context.Context, specReader *spec.SpecReader, connSpec spec.ConnectionSpec, pm *plugin.PluginManager) error {
	sourceSpec := specReader.GetSourceByName(connSpec.Source)

	sourceClient, err := pm.GetSourcePluginClient(ctx, sourceSpec)
	if err != nil {
		return fmt.Errorf("failed to get source plugin client: %w", err)
	}

	destinationClient, err := pm.GetDestinationClient(
		ctx,
		specReader.GetDestinatinoByName(connSpec.Destination),
		plugins.DestinationPluginOptions{},
	)
	if err != nil {
		return fmt.Errorf("failed to get destination plugin client: %w", err)
	}
	if err := destinationClient.Configure(ctx, specReader.GetDestinatinoByName(connSpec.Destination)); err != nil {
		return fmt.Errorf("failed to configure destination plugin client: %w", err)
	}
	tables, err := sourceClient.GetTables(ctx)
	if err != nil {
		return fmt.Errorf("failed to get tables: %w", err)
	}
	if err := destinationClient.CreateTables(ctx, tables); err != nil {
		return fmt.Errorf("failed to create tables: %w", err)
	}
	resources := make(chan []byte)
	g, ctx := errgroup.WithContext(ctx)
	g.Go(func() error {
		defer close(resources)
		jsonSchemaResult, err := sourceClient.Fetch(ctx, sourceSpec, resources)
		if err != nil {
			return fmt.Errorf("failed to fetch resources: %w", err)
		}
		for _, resultError := range jsonSchemaResult.Errors() {
			fmt.Println(resultError.String())
		}
		return fmt.Errorf("failed to validate schema")
	})

	g.Go(func() error {
		// defer close(resources)
		if err := destinationClient.Save(ctx, resources); err != nil {
			return fmt.Errorf("failed to save resources: %w", err)
		}
		return nil
	})

	return g.Wait()

}
